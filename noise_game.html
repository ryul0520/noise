<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>개선된 맵과 깃발</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; cursor: none; }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <script>
    // GitHub에서 정상 실행되도록 DOMContentLoaded 이벤트 리스너로 모든 코드를 감쌌습니다.
    window.addEventListener('DOMContentLoaded', () => {

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        ctx.imageSmoothingEnabled = false;

        const GRAVITY = 0.8;
        const JUMP_FORCE = -14;
        const PLAYER_ACCEL = 1.5;
        const FRICTION = 0.88;
        const MAX_SPEED = 8;
        const PLAYER_TEXTURE_SIZE = 128;

        const player = {
            worldX: 200, worldY: 0,
            dx: 0, dy: 0,
            radius: 24,
            onGround: false,
            rotationAngle: 0,
            initialX: 200,
            initialY: 0,
        };
        const camera = { x: 0, y: 0 };
        
        let worldObjects = [];
        let goal;

        // 기록 변수
        let highestX = 0; // 현재 판의 최고 기록
        let sessionRecordX = 0; // 세션 전체의 최고 기록
        let recordPlatform = null;

        const bgCanvas = document.createElement('canvas');
        const bgCtx = bgCanvas.getContext('2d');
        let bgPattern;

        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.code.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code.toLowerCase()] = false; });

        function getStaticNoiseValue(x, y) { let seed = Math.floor(x) * 1357 + Math.floor(y) * 2468; let t = seed += 1831565813; t = Math.imul(t ^ t >>> 15, 1 | t); t ^= t + Math.imul(t ^ t >>> 7, 61 | t); return ((t ^ t >>> 14) >>> 0) % 2 === 0 ? 0 : 255; }
        function getFlowingNoiseValue(x, y, time) { const flowingX = x + time * 2; let seed = Math.floor(flowingX) * 16807 + Math.floor(y) * 37; let t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, 1 | t); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) % 2 === 0 ? 0 : 255; }
        
        const playerTextureCanvas = document.createElement('canvas'); const pTextureCtx = playerTextureCanvas.getContext('2d'); playerTextureCanvas.width = PLAYER_TEXTURE_SIZE; playerTextureCanvas.height = PLAYER_TEXTURE_SIZE;

        function updatePlayerTexture() {
            if (Math.abs(player.dx) > 0.1 || !player.onGround) {
                const imageData = pTextureCtx.createImageData(PLAYER_TEXTURE_SIZE, PLAYER_TEXTURE_SIZE);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const shade = Math.random() < 0.5 ? 0 : 255;
                    data[i] = shade; data[i+1] = shade; data[i+2] = shade; data[i+3] = 255;
                }
                pTextureCtx.putImageData(imageData, 0, 0);
            }
        }
        
        function updatePlayer() {
            if (keys['keya'] || keys['arrowleft']) { player.dx -= PLAYER_ACCEL; player.rotationAngle -= 0.05; }
            if (keys['keyd'] || keys['arrowright']) { player.dx += PLAYER_ACCEL; player.rotationAngle += 0.05; }
            if ((keys['keyw'] || keys['arrowup'] || keys['space']) && player.onGround) { player.dy = JUMP_FORCE; }
            
            player.dx *= FRICTION;
            if (Math.abs(player.dx) < 0.1) player.dx = 0;
            if (Math.abs(player.dx) > MAX_SPEED) player.dx = Math.sign(player.dx) * MAX_SPEED;
            player.dy += GRAVITY;

            const physicalObjects = worldObjects.filter(o => o.isPhysical);

            player.worldX += player.dx;
            for (const p of physicalObjects) {
                if (checkCollision(player, p).colliding) {
                    const playerCenterX = player.worldX;
                    const platformCenterX = p.worldX + p.width / 2;
                    if (playerCenterX < platformCenterX) player.worldX = p.worldX - player.radius;
                    else player.worldX = p.worldX + p.width + player.radius;
                    player.dx = 0;
                }
            }
            
            player.worldY += player.dy;
            player.onGround = false;
            for (const p of physicalObjects) {
                if (checkCollision(player, p).colliding) {
                    if (player.dy >= 0) {
                        if (player.worldY > p.worldY - player.radius) {
                            player.worldY = p.worldY - player.radius;
                            player.onGround = true;
                            player.dy = 0;
                        }
                    } else {
                        player.worldY = p.worldY + p.height + player.radius;
                        player.dy = 0;
                    }
                }
            }
            
            if (player.worldX > highestX) { highestX = player.worldX; }
            if (player.worldX > goal.x) { alert("신호의 끝에 도달했습니다."); init(); }
            if (player.worldY > height + 200) resetPlayer();
        }

        function checkCollision(playerObj, platformObj) {
            const closestX = Math.max(platformObj.worldX, Math.min(playerObj.worldX, platformObj.worldX + platformObj.width));
            const closestY = Math.max(platformObj.worldY, Math.min(playerObj.worldY, platformObj.worldY + platformObj.height));
            const distanceX = playerObj.worldX - closestX;
            const distanceY = playerObj.worldY - closestY;
            const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);
            return { colliding: distanceSquared < (playerObj.radius * playerObj.radius) };
        }
        
        function resetPlayer() {
            if (highestX > sessionRecordX) { sessionRecordX = highestX; }
            highestX = 0;
            updateRecordPlatform();

            player.worldX = player.initialX;
            player.worldY = player.initialY;
            player.dx = 0;
            player.dy = 0;
        }
        
        function renderWorld() {
            ctx.save();
            ctx.translate(-(camera.x * 0.2) % 1024, -(camera.y * 0.2) % 1024);
            ctx.fillStyle = bgPattern;
            ctx.fillRect((camera.x * 0.2) % 1024, (camera.y * 0.2) % 1024, width, height);
            ctx.restore();

            const physicalObjects = worldObjects.filter(o => o.isPhysical);
            physicalObjects.forEach(obj => {
                const screenX = Math.floor(obj.worldX - camera.x);
                const screenY = Math.floor(obj.worldY - camera.y);
                if (screenX + obj.width*1.5 < 0 || screenX - obj.width*0.5 > width || screenY + obj.height*1.5 < 0 || screenY - obj.height*0.5 > height) return;
                
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(screenX + obj.width, screenY);
                ctx.lineTo(screenX + obj.width, screenY + obj.height);
                ctx.arc(screenX + obj.width / 2, screenY + obj.height, obj.width / 2, 0, Math.PI, false);
                ctx.closePath();
                ctx.clip();
                
                ctx.translate(-(camera.x % 1024), -(camera.y % 1024));
                ctx.fillStyle = bgPattern;
                ctx.fillRect(camera.x % 1024, camera.y % 1024, width, height);
                ctx.restore();
            });
        }
        
        function drawRecordFlag() {
            if (!recordPlatform) return;
            const flagWidth = 40, flagHeight = 25, poleHeight = 50, poleWidth = 2;
            const platformCenterX = recordPlatform.worldX + recordPlatform.width / 2;
            const platformTopY = recordPlatform.worldY;
            const screenPoleX = Math.floor(platformCenterX - camera.x);
            const screenPoleTopY = Math.floor(platformTopY - poleHeight - camera.y);

            if (screenPoleX + flagWidth < 0 || screenPoleX - poleWidth > width) return;

            const poleImageData = ctx.createImageData(poleWidth, poleHeight);
            const poleData = poleImageData.data;
            for (let y = 0; y < poleHeight; y++) { for (let x = 0; x < poleWidth; x++) { const shade = getStaticNoiseValue(x, y + 100); const index = (y * poleWidth + x) * 4; poleData[index] = shade; poleData[index+1] = shade; poleData[index+2] = shade; poleData[index+3] = 255; } }
            ctx.putImageData(poleImageData, screenPoleX - Math.floor(poleWidth/2), screenPoleTopY);

            const flagImageData = ctx.createImageData(flagWidth, flagHeight);
            const flagData = flagImageData.data;
            for (let y = 0; y < flagHeight; y++) { for (let x = 0; x < flagWidth; x++) { const shade = getStaticNoiseValue(x, y); const index = (y * flagWidth + x) * 4; flagData[index] = shade; flagData[index+1] = shade; flagData[index+2] = shade; flagData[index+3] = 255; } }
            ctx.putImageData(flagImageData, screenPoleX, screenPoleTopY);
        }

        function drawGoal(time) { const screenX = Math.floor(goal.x - camera.x); const screenY = Math.floor(goal.y - camera.y); if (screenX + goal.width < 0 || screenX > width) return; const imageData = ctx.createImageData(goal.width, goal.height); const data = imageData.data; for(let y = 0; y < goal.height; y++) { for(let x = 0; x < goal.width; x++) { const shade = getFlowingNoiseValue(x, y, time); const index = (y * goal.width + x) * 4; data[index] = shade; data[index+1] = shade; data[index+2] = shade; data[index+3] = 255; } } ctx.putImageData(imageData, screenX, screenY); }
        function drawPlayer() { const screenX = width / 2; const screenY = height / 2; ctx.save(); ctx.beginPath(); ctx.arc(screenX, screenY, player.radius, 0, Math.PI * 2); ctx.clip(); ctx.translate(screenX, screenY); ctx.rotate(player.rotationAngle); ctx.drawImage(playerTextureCanvas, -PLAYER_TEXTURE_SIZE / 2, -PLAYER_TEXTURE_SIZE / 2); ctx.restore(); }

        let lastTime = 0;
        function animate(time) {
            if(!lastTime) lastTime = time;
            updatePlayer(); updatePlayerTexture();
            camera.x = player.worldX - (width / 2); camera.y = player.worldY - (height / 2);
            renderWorld(); drawRecordFlag(); drawGoal(time / 100); drawPlayer();
            requestAnimationFrame(animate);
        }

        function createBackgroundPattern() { const pS = 1024; bgCanvas.width=pS; bgCanvas.height=pS; const iD = bgCtx.createImageData(pS, pS); const d = iD.data; for(let i=0; i<d.length; i+=4) { const s = getStaticNoiseValue(i % pS, Math.floor(i / pS)); d[i]=s; d[i+1]=s; d[i+2]=s; d[i+3]=255; } bgCtx.putImageData(iD, 0, 0); bgPattern = ctx.createPattern(bgCanvas, 'repeat'); }

        function updateRecordPlatform() {
            const physicalPlatforms = worldObjects.filter(o => o.isPhysical);
            let bestPlatform = null;
            for (const p of physicalPlatforms) {
                if (p.worldX <= sessionRecordX) { bestPlatform = p; } 
                else { break; }
            }
            recordPlatform = bestPlatform;
        }

        function init() {
            width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight;
            highestX = 0;
            sessionRecordX = 0;
            player.initialY = height - 200;
            resetPlayer();

            const platforms = [];
            let currentX = 100;
            let prevY = height - 100;
            platforms.push({ worldX: currentX, worldY: prevY, width: 250, height: 40, isPhysical: true, shape: 'rect' });
            const platformCount = 50, MAX_X_GAP = 220, MIN_X_GAP = 100, MAX_Y_CHANGE = 120;
            for (let i=0; i < platformCount; i++) {
                const xGap = MIN_X_GAP + Math.random() * (MAX_X_GAP - MIN_X_GAP);
                const yChange = (Math.random() - 0.5) * 2 * MAX_Y_CHANGE;
                let platformWidth = 60 + Math.random() * 100;
                currentX += xGap;
                let newY = prevY + yChange;
                if (newY > height - 60) newY = height - 60;
                if (newY < 150) newY = 150;
                platforms.push({ worldX: currentX, worldY: newY, width: platformWidth, height: 20, isPhysical: true, shape: 'rect' });
                prevY = newY;
            }

            worldObjects = [
                { worldX: -10000, worldY: -10000, width: 100000, height: 20000, isPhysical: false, shape: 'rect' },
                ...platforms
            ];
            goal = { x: currentX + 500, y: 0, width: 50, height: height * 2 };
            if (!bgPattern) createBackgroundPattern();
            updatePlayerTexture();
        }

        window.addEventListener('resize', init);
        init();
        animate(0);
    });
    </script>
</body>
</html>