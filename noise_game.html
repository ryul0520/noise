<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>최종 복구</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; cursor: none; }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        ctx.imageSmoothingEnabled = false;

        const GRAVITY = 0.8;
        const JUMP_FORCE = -14;
        const PLAYER_ACCEL = 1.5;
        const FRICTION = 0.88;
        const MAX_SPEED = 8;
        const PLAYER_TEXTURE_SIZE = 128;

        const player = {
            worldX: 200, worldY: 0,
            dx: 0, dy: 0,
            radius: 24,
            onGround: false,
            rotationAngle: 0,
            initialX: 200,
            initialY: 0,
        };
        const playerHitbox = { width: player.radius * 1.5, height: player.radius * 2 };
        const camera = { x: 0, y: 0 };
        
        let worldObjects = [];
        let goal;

        const bgCanvas = document.createElement('canvas');
        const bgCtx = bgCanvas.getContext('2d');
        let bgPattern;

        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.code.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code.toLowerCase()] = false; });

        function getStaticNoiseValue(x, y) { let seed = Math.floor(x) * 1357 + Math.floor(y) * 2468; let t = seed += 1831565813; t = Math.imul(t ^ t >>> 15, 1 | t); t ^= t + Math.imul(t ^ t >>> 7, 61 | t); return ((t ^ t >>> 14) >>> 0) % 2 === 0 ? 0 : 255; }
        function getFlowingNoiseValue(x, y, time) { const flowingX = x + time * 2; let seed = Math.floor(flowingX) * 16807 + Math.floor(y) * 37; let t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, 1 | t); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) % 2 === 0 ? 0 : 255; }
        const playerTextureCanvas = document.createElement('canvas'); const pTextureCtx = playerTextureCanvas.getContext('2d'); playerTextureCanvas.width = PLAYER_TEXTURE_SIZE; playerTextureCanvas.height = PLAYER_TEXTURE_SIZE;
        function createPlayerNoiseTexture() { const imageData = pTextureCtx.createImageData(PLAYER_TEXTURE_SIZE, PLAYER_TEXTURE_SIZE); const data = imageData.data; for (let i = 0; i < data.length; i += 4) { const shade = Math.random() < 0.5 ? 0 : 255; data[i] = shade; data[i+1] = shade; data[i+2] = shade; data[i+3] = 255; } pTextureCtx.putImageData(imageData, 0, 0); }
        
        // ✨ 안정적인 충돌 로직으로 복원
        function updatePlayer() {
            if (keys['keya'] || keys['arrowleft']) { player.dx -= PLAYER_ACCEL; player.rotationAngle -= 0.05; }
            if (keys['keyd'] || keys['arrowright']) { player.dx += PLAYER_ACCEL; player.rotationAngle += 0.05; }
            if ((keys['keyw'] || keys['arrowup'] || keys['space']) && player.onGround) { player.dy = JUMP_FORCE; }
            
            player.dx *= FRICTION;
            if (Math.abs(player.dx) < 0.1) player.dx = 0;
            if (Math.abs(player.dx) > MAX_SPEED) player.dx = Math.sign(player.dx) * MAX_SPEED;
            
            player.dy += GRAVITY;

            const physicalObjects = worldObjects.filter(o => o.isPhysical);
            
            player.worldX += player.dx;
            for (const p of physicalObjects) {
                const rectHitbox = { x: player.worldX - playerHitbox.width / 2, y: player.worldY - playerHitbox.height / 2, width: playerHitbox.width, height: playerHitbox.height };
                if (rectHitbox.x < p.worldX + p.width && rectHitbox.x + rectHitbox.width > p.worldX &&
                    rectHitbox.y < p.worldY + p.height && rectHitbox.y + rectHitbox.height > p.worldY) {
                    if (player.dx > 0) {
                        player.worldX = p.worldX - playerHitbox.width / 2;
                    } else if (player.dx < 0) {
                        player.worldX = p.worldX + p.width + playerHitbox.width / 2;
                    }
                    player.dx = 0;
                }
            }

            player.worldY += player.dy;
            player.onGround = false;
            for (const p of physicalObjects) {
                const rectHitbox = { x: player.worldX - playerHitbox.width / 2, y: player.worldY - playerHitbox.height / 2, width: playerHitbox.width, height: playerHitbox.height };
                 if (rectHitbox.x < p.worldX + p.width && rectHitbox.x + rectHitbox.width > p.worldX &&
                     rectHitbox.y < p.worldY + p.height && rectHitbox.y + rectHitbox.height > p.worldY) {
                    if (player.dy > 0) {
                        player.worldY = p.worldY - playerHitbox.height / 2;
                        player.onGround = true;
                        player.dy = 0;
                        if (p.angle) player.dx += p.angle * 0.3; 
                    } else if (player.dy < 0) {
                        player.worldY = p.worldY + p.height + playerHitbox.height / 2;
                        player.dy = 0;
                    }
                }
            }
            
            if (player.worldX > goal.x) { alert("신호의 끝에 도달했습니다."); init(); }
            if (player.worldY > height + 200) resetPlayer();
        }
        
        function resetPlayer() { player.worldX = player.initialX; player.worldY = player.initialY; player.dx = 0; player.dy = 0; }
        
        function renderWorld() {
            ctx.save();
            ctx.translate(-(camera.x * 0.2) % 1024, -(camera.y * 0.2) % 1024);
            ctx.fillStyle = bgPattern;
            ctx.fillRect((camera.x * 0.2) % 1024, (camera.y * 0.2) % 1024, width, height);
            ctx.restore();

            const physicalObjects = worldObjects.filter(o => o.isPhysical);
            physicalObjects.forEach(obj => {
                const screenX = Math.floor(obj.worldX - camera.x);
                const screenY = Math.floor(obj.worldY - camera.y);
                if (screenX + obj.width*1.5 < 0 || screenX - obj.width*0.5 > width || screenY + obj.height*1.5 < 0 || screenY - obj.height*0.5 > height) return;
                
                ctx.save();
                
                ctx.translate(screenX + obj.width/2, screenY + obj.height/2);
                ctx.rotate(obj.angle || 0);
                ctx.translate(-(screenX + obj.width/2), -(screenY + obj.height/2));

                ctx.beginPath();
                if (obj.shape === 'rect') { ctx.rect(screenX, screenY, obj.width, obj.height); } 
                else if (obj.shape === 'circle') { ctx.arc(screenX + obj.width/2, screenY + obj.height/2, obj.width/2, 0, Math.PI * 2); }
                ctx.clip();
                
                ctx.rotate(-(obj.angle || 0));

                ctx.translate(-(camera.x % 1024), -(camera.y % 1024));
                ctx.fillStyle = bgPattern;
                ctx.fillRect(camera.x % 1024 - (screenX + obj.width/2), camera.y % 1024 - (screenY + obj.height/2), width * 2, height * 2);
                ctx.restore();
            });
        }

        function drawGoal(time) { const screenX = Math.floor(goal.x - camera.x); const screenY = Math.floor(goal.y - camera.y); if (screenX + goal.width < 0 || screenX > width) return; const imageData = ctx.createImageData(goal.width, goal.height); const data = imageData.data; for(let y = 0; y < goal.height; y++) { for(let x = 0; x < goal.width; x++) { const shade = getFlowingNoiseValue(x, y, time); const index = (y * goal.width + x) * 4; data[index] = shade; data[index+1] = shade; data[index+2] = shade; data[index+3] = 255; } } ctx.putImageData(imageData, screenX, screenY); }
        function drawPlayer() { const screenX = width / 2; const screenY = height / 2; ctx.save(); ctx.beginPath(); ctx.arc(screenX, screenY, player.radius, 0, Math.PI * 2); ctx.clip(); ctx.translate(screenX, screenY); ctx.rotate(player.rotationAngle); ctx.drawImage(playerTextureCanvas, -PLAYER_TEXTURE_SIZE / 2, -PLAYER_TEXTURE_SIZE / 2); ctx.restore(); }

        let lastTime = 0;
        function animate(time) { if(!lastTime) lastTime = time; updatePlayer(); camera.x = player.worldX - (width / 2); camera.y = player.worldY - (height / 2); renderWorld(); drawGoal(time / 100); drawPlayer(); requestAnimationFrame(animate); }

        function createBackgroundPattern() { const pS = 1024; bgCanvas.width=pS; bgCanvas.height=pS; const iD = bgCtx.createImageData(pS, pS); const d = iD.data; for(let i=0; i<d.length; i+=4) { const s = getStaticNoiseValue(i % pS, Math.floor(i / pS)); d[i]=s; d[i+1]=s; d[i+2]=s; d[i+3]=255; } bgCtx.putImageData(iD, 0, 0); bgPattern = ctx.createPattern(bgCanvas, 'repeat'); }

        function init() {
            width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight;
            player.initialY = height - 200;
            resetPlayer();

            const platforms = [];
            const shapes = ['rect', 'circle'];
            let currentX = 100;
            let currentY = height - 100;
            
            platforms.push({ worldX: 100, worldY: height - 100, width: 250, height: 40, isPhysical: true, shape: 'rect', angle: 0 });

            for (let i=0; i < 50; i++) {
                const shape = shapes[Math.floor(Math.random() * shapes.length)];
                const xGap = 180 + Math.random() * 150; 
                const yGap = (Math.random() - 0.5) * 220;
                let platformWidth, platformHeight, platformAngle = 0;
                
                if (shape === 'rect') {
                    platformWidth = 80 + Math.random() * 120;
                    platformHeight = 20;
                    platformAngle = (Math.random() - 0.5) * 0.6;
                } else if (shape === 'circle') {
                    platformWidth = 80 + Math.random() * 100;
                    platformHeight = platformWidth;
                }
                
                currentX += xGap;
                currentY += yGap;

                if (currentY > height - 60) currentY = height - 60;
                if (currentY < 150) currentY = 150;

                platforms.push({
                    worldX: currentX, worldY: currentY,
                    width: platformWidth, height: platformHeight,
                    isPhysical: true, shape: shape, angle: platformAngle
                });
            }

            worldObjects = [
                { worldX: -10000, worldY: -10000, width: 100000, height: 20000, parallaxFactor: 0.2, isPhysical: false, shape: 'rect' },
                ...platforms
            ];
            
            goal = { x: currentX + 500, y: 0, width: 50, height: height * 2 };
            
            if (!bgPattern) createBackgroundPattern();
            createPlayerNoiseTexture();
        }

        window.addEventListener('resize', init);
        init();
        animate(0);
    </script>
</body>
</html>